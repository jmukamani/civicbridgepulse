import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { keys as idbKeys, get as idbGet, del as idbDel, update as idbUpdate } from 'idb-keyval';

// Get the API base URL from environment or default to current origin
const getApiBase = () => {
  if (typeof importScripts === 'function') {
    try {
      const urlParams = new URLSearchParams(self.location.search);
      const apiBase = urlParams.get('apiBase');
      if (apiBase) return apiBase;
    } catch (e) {}
  }
  
  // Default API base patterns to match
  const apiPatterns = [
    self.location.origin,               // current origin first (dev or prod)
    'http://localhost:5000',            // common local API
    'https://cap-app-civicbridge.azurewebsites.net' // production fallback
  ];
  
  return apiPatterns;
};

const apiBasePatterns = getApiBase();

// Helper function to check if a URL is an API URL we should cache
const isApiUrl = (url) => {
  if (Array.isArray(apiBasePatterns)) {
    return apiBasePatterns.some(pattern => url.href.startsWith(pattern + '/api/'));
  }
  return url.href.startsWith(apiBasePatterns + '/api/');
};

// Helper function to check if a URL is a policy file URL we should cache
const isPolicyFileUrl = (url) => {
  if (Array.isArray(apiBasePatterns)) {
    return apiBasePatterns.some(pattern => 
      url.href.startsWith(pattern + '/uploads/policies/') ||
      url.href.includes('/uploads/policies/')
    );
  }
  return url.href.startsWith(apiBasePatterns + '/uploads/policies/') ||
         url.href.includes('/uploads/policies/');
};

// Precache all of the assets generated by the build
precacheAndRoute(self.__WB_MANIFEST || []);

// Runtime caching for images (cache-first)
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 60 * 60 * 24 * 30 }),
    ],
  }),
);

// Runtime caching for LOCAL API calls (network-first)
registerRoute(
  ({ url, request }) =>
    url.origin === self.location.origin &&
    url.pathname.startsWith('/api/') &&
    request.method === 'GET',
  new NetworkFirst({
    cacheName: 'local-api-cache',
    networkTimeoutSeconds: 10,
    plugins: [
      new ExpirationPlugin({ maxEntries: 50, maxAgeSeconds: 60 * 60 * 24 }),
    ],
  }),
);

// Runtime caching for EXTERNAL API calls with custom strategy that handles auth failures
registerRoute(
  ({ url, request }) => 
    isApiUrl(url) && request.method === 'GET',
  new NetworkFirst({
    cacheName: 'external-api-cache',
    networkTimeoutSeconds: 5,
    plugins: [
      new ExpirationPlugin({ 
        maxEntries: 100, 
        maxAgeSeconds: 60 * 60 * 24 * 7 // 7 days for external API cache
      }),
      {
        // Custom plugin to handle auth errors gracefully
        requestWillFetch: async ({ request }) => {
          return request;
        },
        fetchDidFail: async ({ originalRequest, error }) => {
          console.warn('External API fetch failed:', originalRequest.url, error);
        },
        cacheWillUpdate: async ({ response }) => {
          // Don't cache auth errors or server errors
          return response.status === 200 ? response : null;
        }
      }
    ],
  }),
);

// Cache policy PDFs and docs with a CacheFirst strategy
registerRoute(
  ({ url }) => isPolicyFileUrl(url),
  new CacheFirst({
    cacheName: 'policy-files',
    plugins: [
      new ExpirationPlugin({ maxEntries: 50, maxAgeSeconds: 60 * 60 * 24 * 365 }),
    ],
  }),
);

// Cache any uploaded resources (generic) from local origin
registerRoute(
  ({ url }) => url.origin === self.location.origin && url.pathname.startsWith('/uploads/'),
  new CacheFirst({
    cacheName: 'uploads-files',
    plugins: [
      new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 60 * 60 * 24 * 365 }),
    ],
  }),
);

// Constants for priority + retry
const MAX_RETRIES = 5;

// Background Sync for queued actions
self.addEventListener('sync', (event) => {
  if (event.tag === 'cbp-sync') {
    event.waitUntil(handleSync());
  }
});

async function handleSync() {
  const keys = await idbKeys();
  const queue = [];
  for (const k of keys) {
    if (typeof k !== 'string' || !k.startsWith('q-')) continue;
    const act = await idbGet(k);
    if (!act) continue;
    queue.push({ key: k, ...act });
  }

  // sort by priority,timestamp (was pre-sorted in helper but double-check)
  queue.sort((a,b)=>{
    if(a.priority!==b.priority) return a.priority-b.priority;
    return (a.timestamp||0)-(b.timestamp||0);
  });

  for(const item of queue){
    const { key, type, payload, token, retries=0 } = item;

    try {
      let apiBase;
      if (Array.isArray(apiBasePatterns)) {
        // Prefer localhost pattern during development if available
        apiBase = apiBasePatterns.find(p => p.startsWith('http://localhost')) || apiBasePatterns[0];
      } else {
        apiBase = apiBasePatterns;
      }
      
      if (type === 'issue') {
        await fetch(`${apiBase}/api/issues`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
          body: JSON.stringify(payload),
        });
      } else if (type === 'message') {
        const resp = await fetch(`${apiBase}/api/messages/send`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
          body: JSON.stringify(payload),
        });
        const saved = await resp.json();
        item.serverId = saved.id;
      } else if (type === 'pollVote') {
        await fetch(`${apiBase}/api/polls/${payload.pollId}/vote`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
          body: JSON.stringify({ selected: payload.selected }),
        });
      } else if (type === 'profileUpdate') {
        await fetch(`${apiBase}/api/users/profile`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
          body: JSON.stringify(payload),
        });
      } else if (type === 'event') {
        await fetch(`${apiBase}/api/events`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
          body: JSON.stringify(payload),
        });
      } else if (type === 'thread') {
        await fetch(`${apiBase}/api/forums/threads`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
          body: JSON.stringify(payload),
        });
      } else if (type === 'forumPost') {
        await fetch(`${apiBase}/api/forums/threads/${payload.threadId}/posts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
          body: JSON.stringify({ content: payload.content }),
        });
      } else if (type === 'resourceBookmark') {
        await fetch(`${apiBase}/api/resources/${payload.resourceId}/bookmark`, {
          method: 'POST',
          headers: { Authorization: `Bearer ${token}` },
        });
      }

      // success: remove and notify clients
      await idbDel(key);
      const clients = await self.clients.matchAll({ includeUncontrolled: true });
      if (item.localId) {
        clients.forEach(c=>c.postMessage({ type: 'messageSynced', localId: item.localId, serverId: item.serverId }));
      }
    } catch(err){
      console.error('sync error', err);
      // increment retry, or delete if exceeds
      await idbUpdate(key, val=>{
        if(!val) return;
        val.retries = (val.retries||0)+1;
        if(val.retries >= MAX_RETRIES){
          return undefined; // delete
        }
        return val;
      });
      if(retries+1 >= MAX_RETRIES){
        const clients = await self.clients.matchAll({ includeUncontrolled: true });
        clients.forEach(c=>c.postMessage({ type: 'messageFailed', localId: item.localId }));
      }
    }
  }
}

// Push Notifications
self.addEventListener('push', (event) => {
  const data = event.data ? event.data.json() : {};
  const title = data.title || 'Notification';
  const options = {
    body: data.body,
    data: data.data,
    icon: '/favicon-96x96.png',
  };
  event.waitUntil(self.registration.showNotification(title, options));
});

self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  const url = '/';
  event.waitUntil(clients.openWindow(url));
}); 