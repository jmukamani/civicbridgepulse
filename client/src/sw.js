import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { keys as idbKeys, get as idbGet, del as idbDel, update as idbUpdate } from 'idb-keyval';

// Precache all of the assets generated by the build
precacheAndRoute(self.__WB_MANIFEST || []);

// Runtime caching for images (cache-first)
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 60 * 60 * 24 * 30 }),
    ],
  }),
);

// Runtime caching for API calls (network-first)
registerRoute(
  ({ url, request }) => url.origin === self.location.origin && url.pathname.startsWith('/api/') && request.method === 'GET',
  new NetworkFirst({
    cacheName: 'api-cache',
    networkTimeoutSeconds: 10,
    plugins: [
      new ExpirationPlugin({ maxEntries: 50, maxAgeSeconds: 60 * 60 * 24 }),
    ],
  }),
);

// Cache policy PDFs and docs with a CacheFirst strategy, limit entries & size
registerRoute(
  ({ url }) => url.pathname.startsWith('/uploads/policies/'),
  new CacheFirst({
    cacheName: 'policy-files',
    plugins: [
      new ExpirationPlugin({ maxEntries: 50, maxAgeSeconds: 60 * 60 * 24 * 365 }),
    ],
  }),
);

// Cache any uploaded resources (generic)
registerRoute(
  ({ url }) => url.pathname.startsWith('/uploads/'),
  new CacheFirst({
    cacheName: 'uploads-files',
    plugins: [
      new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 60 * 60 * 24 * 365 }),
    ],
  }),
);

// Constants for priority + retry
const MAX_RETRIES = 5;

// Background Sync for queued actions
self.addEventListener('sync', (event) => {
  if (event.tag === 'cbp-sync') {
    event.waitUntil(handleSync());
  }
});

async function handleSync() {
  const keys = await idbKeys();
  const queue = [];
  for (const k of keys) {
    if (typeof k !== 'string' || !k.startsWith('q-')) continue;
    const act = await idbGet(k);
    if (!act) continue;
    queue.push({ key: k, ...act });
  }

  // sort by priority,timestamp (was pre-sorted in helper but double-check)
  queue.sort((a,b)=>{
    if(a.priority!==b.priority) return a.priority-b.priority;
    return (a.timestamp||0)-(b.timestamp||0);
  });

  for(const item of queue){
    const { key, type, payload, token, retries=0 } = item;

    try {
      if (type === 'issue') {
        await fetch('/api/issues', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
          body: JSON.stringify(payload),
        });
      } else if (type === 'message') {
        const resp = await fetch('/api/messages/send', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
          body: JSON.stringify(payload),
        });
        const saved = await resp.json();
        item.serverId = saved.id;
      } else if (type === 'pollVote') {
        await fetch(`/api/polls/${payload.pollId}/vote`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
          body: JSON.stringify({ selected: payload.selected }),
        });
      } else if (type === 'profileUpdate') {
        await fetch('/api/users/profile', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
          body: JSON.stringify(payload),
        });
      } else if (type === 'event') {
        await fetch('/api/events', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
          body: JSON.stringify(payload),
        });
      } else if (type === 'thread') {
        await fetch('/api/forums/threads', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
          body: JSON.stringify(payload),
        });
      } else if (type === 'forumPost') {
        await fetch(`/api/forums/threads/${payload.threadId}/posts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
          body: JSON.stringify({ content: payload.content }),
        });
      } else if (type === 'resourceBookmark') {
        await fetch(`/api/resources/${payload.resourceId}/bookmark`, {
          method: 'POST',
          headers: { Authorization: `Bearer ${token}` },
        });
      }

      // success: remove and notify clients
      await idbDel(key);
      const clients = await self.clients.matchAll({ includeUncontrolled: true });
      if (item.localId) {
        clients.forEach(c=>c.postMessage({ type: 'messageSynced', localId: item.localId, serverId: item.serverId }));
      }
    } catch(err){
      console.error('sync error', err);
      // increment retry, or delete if exceeds
      await idbUpdate(key, val=>{
        if(!val) return;
        val.retries = (val.retries||0)+1;
        if(val.retries >= MAX_RETRIES){
          return undefined; // delete
        }
        return val;
      });
      if(retries+1 >= MAX_RETRIES){
        const clients = await self.clients.matchAll({ includeUncontrolled: true });
        clients.forEach(c=>c.postMessage({ type: 'messageFailed', localId: item.localId }));
      }
    }
  }
}

// Push Notifications
self.addEventListener('push', (event) => {
  const data = event.data ? event.data.json() : {};
  const title = data.title || 'Notification';
  const options = {
    body: data.body,
    data: data.data,
    icon: '/favicon-96x96.png',
  };
  event.waitUntil(self.registration.showNotification(title, options));
});

self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  const url = '/';
  event.waitUntil(clients.openWindow(url));
}); 